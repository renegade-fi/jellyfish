//! Proof linking primitives for Plonk proofs
//!
//! TODO(@joey): detail the proof-linking protocol

use ark_ec::{
    pairing::Pairing,
    short_weierstrass::{Affine, SWCurveConfig},
};
use ark_ff::{FftField, Field, One};
use ark_poly::{univariate::DensePolynomial, DenseUVPolynomial};
use jf_primitives::{
    circuit,
    pcs::{
        prelude::{Commitment, UnivariateKzgPCS, UnivariateKzgProof},
        PolynomialCommitmentScheme,
    },
    rescue::RescueParameter,
};
use mpc_relation::{
    errors::CircuitError,
    gadgets::ecc::SWToTEConParam,
    proof_linking::{GroupLayout, PROOF_LINK_WIRE_IDX},
    traits::LinkGroup,
    PlonkCircuit,
};

use crate::{errors::PlonkError, transcript::PlonkTranscript};

use super::{
    structs::{CommitKey, Proof, ProvingKey},
    PlonkKzgSnark,
};

/// A proof that two circuits are linked on a given domain
#[derive(Clone, Debug)]
pub struct LinkingProof<E: Pairing> {
    /// The start of the linking domain in the witnesses
    domain_gen: E::ScalarField,
    /// The size of the linking domain in the witness
    ///
    /// The domain is generated by the powers of `domain_gen`
    domain_size: usize,
    /// The commitment to the linking quotient polynomial
    quotient_commitment: Commitment<E>,
    /// The proof of opening of the linking identity polynomial
    opening_proof: UnivariateKzgProof<E>,
}

/// Proof linking impls
impl<E, F, P> PlonkKzgSnark<E>
where
    E: Pairing<BaseField = F, G1Affine = Affine<P>>,
    F: RescueParameter + SWToTEConParam,
    P: SWCurveConfig<BaseField = F>,
{
    /// Link two proofs on a given domain
    pub fn link_proofs<T: PlonkTranscript<F>>(
        lhs_circuit: &PlonkCircuit<E::ScalarField>,
        rhs_circuit: &PlonkCircuit<E::ScalarField>,
        lhs_proof: &Proof<E>,
        rhs_proof: &Proof<E>,
        proving_key: &ProvingKey<E>,
        link_group: &LinkGroup,
    ) -> Result<LinkingProof<E>, PlonkError> {
        // Get the placement of the group in the circuit's layout
        let circuit_layout = lhs_circuit.gen_circuit_layout().map_err(PlonkError::CircuitError)?;
        let group_layout = circuit_layout.group_layouts.get(&link_group.id).ok_or_else(|| {
            PlonkError::CircuitError(CircuitError::LinkGroupNotFound(format!(
                "link group {} not found in layout",
                link_group.id
            )))
        })?;

        // Compute the quotient then commit to it
        let quotient = Self::compute_linking_quotient(lhs_circuit, rhs_circuit, &group_layout)?;
        let quotient_commitment = UnivariateKzgPCS::commit(&proving_key.commit_key, &quotient)
            .map_err(PlonkError::PCSError)?;

        // Squeeze a challenge for the opening
        let opening_challenge =
            Self::compute_quotient_challenge::<T>(lhs_proof, rhs_proof, &quotient_commitment)?;
        let (opening_proof, _) =
            UnivariateKzgPCS::open(&proving_key.commit_key, &quotient, &opening_challenge)
                .map_err(PlonkError::PCSError)?;

        Ok(LinkingProof::<E> {
            domain_gen: group_layout.get_domain_generator(),
            domain_size: group_layout.size,
            quotient_commitment,
            opening_proof,
        })
    }

    /// Compute the quotient polynomial for the linking proof
    ///
    /// Let the LHS proof's a(x) wiring polynomial be a_1(x) and the RHS proof's
    /// a(x) wiring polynomial be a_2(x). Then the quotient polynomial is:
    ///     q(x) = (a_1(x) - a_2(x)) / Z_D(x)
    /// Where Z_D(x) is the vanishing polynomial for the linking domain D
    fn compute_linking_quotient(
        lhs_circuit: &PlonkCircuit<E::ScalarField>,
        rhs_circuit: &PlonkCircuit<E::ScalarField>,
        group_layout: &GroupLayout,
    ) -> Result<DensePolynomial<E::ScalarField>, PlonkError> {
        let vanishing_poly = Self::compute_vanishing_polynomial(group_layout)?;

        // Compute the difference of the wiring polynomials
        let a1 = lhs_circuit.get_proof_linking_wire_poly();
        let a2 = rhs_circuit.get_proof_linking_wire_poly();
        let diff = &a1 - &a2;

        // Divide the difference by the vanishing polynomial
        Ok(&diff / &vanishing_poly)
    }

    /// Compute the vanishing polynomial for the layout of a given group
    fn compute_vanishing_polynomial(
        layout: &GroupLayout,
    ) -> Result<DensePolynomial<E::ScalarField>, PlonkError> {
        // Get the generator of the group
        let gen = layout.get_domain_generator::<E::ScalarField>();

        // Compute the vanishing poly:
        //    Z(x) = (x - g^{offset + 1})(x - g^{offset + 2})...(x - g^{offset + size})
        let exp = (layout.offset + 1) as u64;
        let mut curr_root = gen.pow(&[exp]);
        let mut vanishing_poly =
            DensePolynomial::from_coefficients_vec(vec![E::ScalarField::one()]);

        for _ in 0..layout.size {
            let monomial =
                DensePolynomial::from_coefficients_vec(vec![-curr_root, E::ScalarField::one()]);
            vanishing_poly = &vanishing_poly * &monomial;

            curr_root *= &gen;
        }

        Ok(vanishing_poly)
    }

    /// Squeeze a challenge for the quotient opening proof
    ///
    /// This challenge is squeezed from a transcript that absorbs the wire
    /// polynomials that encode proof linking gates
    /// challenge of each proof, thereby branching off the transcripts of
    /// the proofs _after_ they have committed to the wiring polynomials
    /// that are being linked
    fn compute_quotient_challenge<T: PlonkTranscript<E::BaseField>>(
        lhs_proof: &Proof<E>,
        rhs_proof: &Proof<E>,
        quotient_comm: &Commitment<E>,
    ) -> Result<E::ScalarField, PlonkError> {
        let mut transcript = T::new(b"PlonkLinkingProof");

        // We encode the proof linking gates in the first wire polynomial
        let a_comm1 = lhs_proof.wires_poly_comms[PROOF_LINK_WIRE_IDX];
        let a_comm2 = rhs_proof.wires_poly_comms[PROOF_LINK_WIRE_IDX];
        transcript.append_commitments(b"linking_wire_comms", &[a_comm1, a_comm2])?;
        transcript.append_commitment(b"quotient_comm", &quotient_comm)?;

        transcript.get_and_append_challenge::<E>(b"eta")
    }
}
